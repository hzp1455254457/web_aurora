---
alwaysApply: true
---
# web_aurora 工程目录规范与开发指南

<!--
  Cursor Rules Configuration File
  Project: web_aurora (Vue 3 + Vite + TypeScript Web Frontend)
  Purpose: 定义项目开发规范、目录结构、工作流程和 AI 助手行为规则
  Last Updated: 2025
-->

这是一个基于 **Vue 3 + Vite + TypeScript** 的 AI 女友 web 官网项目。请严格按照以下目录分工进行开发。

## 📂 工作区结构

本项目为单工作区项目：

| 工作区路径 | 用途 | 主要内容 |
|-----------|------|----------|
| `D:\DevProject_Web` | **主项目目录** | Vue 3 项目、TypeScript 代码、前端资源 |

**⚠️ 核心原则**：
- 严格遵循目录职责划分，不要越界开发
- 自动生成的代码**绝对禁止手动修改**
- 每次任务完成后**必须发送完成通知**
- 始终使用**中文**进行沟通
- 使用 **OpenSpec** 进行规范驱动的开发
- 使用 **PromptX** 角色系统进行协作
- **OpenSpec + PromptX 必须协同工作**：提案阶段使用角色和记忆，实施阶段使用角色和记忆

**🎯 规则识别优先级**：
1. **OpenSpec 任务**（包含 proposal/change/spec/plan 等关键词）→ 优先执行 OpenSpec 工作流
2. **PromptX 角色任务**（Vue/组件/架构/文档/测试等关键词）→ 优先激活对应角色
3. **标准开发任务** → 遵循标准工作流程

---

## 🏗️ 核心目录结构与职责

### 1. src/ - 源代码目录

**路径**: `src/`  
**职责**: Vue 3 应用的主要源代码目录

**目录结构**:
```
src/
├── assets/              # 静态资源（图片、字体等）
├── components/          # 可复用组件
│   ├── common/          # 通用组件（按钮、输入框等）
│   ├── layout/          # 布局组件（Header、Sidebar等）
│   └── business/        # 业务组件（AI女友相关）
├── views/               # 页面视图组件
│   ├── Home.vue         # 首页
│   ├── About.vue        # 关于页
│   └── ...              # 其他页面
├── router/              # 路由配置
│   └── index.ts         # 路由定义
├── stores/              # 状态管理（Pinia）
│   ├── user.ts          # 用户状态
│   └── ...              # 其他状态模块
├── composables/         # 组合式函数（Composables）
│   ├── useAuth.ts       # 认证相关
│   ├── useApi.ts         # API 调用
│   └── ...              # 其他组合式函数
├── utils/               # 工具函数
│   ├── request.ts       # HTTP 请求封装
│   ├── format.ts         # 格式化工具
│   └── ...              # 其他工具
├── types/               # TypeScript 类型定义
│   ├── api.ts           # API 类型
│   ├── user.ts          # 用户类型
│   └── ...              # 其他类型
├── styles/              # 样式文件
│   ├── variables.css    # CSS 变量
│   ├── mixins.css       # CSS Mixins
│   └── global.css       # 全局样式
├── App.vue              # 根组件
├── main.ts              # 入口文件
└── vite-env.d.ts        # Vite 类型声明
```

**开发规则**:
- ✅ 新增页面 → 在 `views/` 下创建
- ✅ 新增可复用组件 → 在 `components/` 下按类型分类
- ✅ 新增业务逻辑 → 在 `composables/` 下创建组合式函数
- ✅ 新增工具函数 → 在 `utils/` 下创建
- ✅ 新增类型定义 → 在 `types/` 下创建
- ✅ 遵循 Vue 3 Composition API 最佳实践
- ✅ 使用 `<script setup>` 语法

**⚠️ 自动生成代码（禁止手动修改）**:
- ❌ `src/vite-env.d.ts` - Vite 自动生成，禁止手动修改
- ❌ 标记为 `// Auto-generated` 的代码块不可手动修改
- ❌ 编译产物（`dist/` 目录）

---

### 2. public/ - 静态资源目录

**路径**: `public/`  
**职责**: 不需要经过构建处理的静态资源

**目录结构**:
```
public/
├── vite.svg            # 网站图标
├── favicon.ico         # 浏览器图标
└── ...                 # 其他静态资源
```

**开发规则**:
- ✅ 直接放在 `public/` 下的文件会被原样复制到构建输出目录
- ✅ 使用绝对路径引用：`/vite.svg`
- ⚠️ 大文件建议使用 CDN 或外部资源

---

### 3. openspec/ - OpenSpec 规范驱动开发

**路径**: `openspec/`  
**职责**: 使用 OpenSpec 进行规范驱动的开发和变更管理

**目录结构**:
```
openspec/
├── AGENTS.md           # AI 助手使用 OpenSpec 的指南
├── project.md          # 项目规范说明
├── specs/              # 系统规范定义
│   ├── navigation/     # 路由导航系统规范
│   ├── state-management/# 状态管理系统规范
│   ├── api-integration/# API 集成规范
│   ├── component-library/# 组件库规范
│   └── ...             # 其他系统规范
├── changes/            # 变更提案和任务
│   └── <change-id>/    # 具体的变更目录
│       ├── proposal.md # 变更提案
│       ├── tasks.md     # 任务清单
│       ├── design.md    # 技术设计（可选）
│       └── specs/       # 规范变更
└── archive/            # 已归档的变更
```

**主要功能**:
- 规范驱动的开发（Spec-Driven Development）
- 变更提案管理
- 系统规范文档化
- AI 助手协作指南

**使用场景**:
- ✅ 新增功能或系统 → 创建变更提案
- ✅ 修改现有功能 → 创建变更提案
- ✅ 查看系统规范 → 阅读 `specs/` 目录下的规范文件
- ✅ 查看变更历史 → 查看 `changes/` 或 `archive/` 目录

**开发规则**:
- ✅ 重大变更前先创建变更提案（proposal）
- ✅ 遵循 OpenSpec 工作流程（见 `openspec/AGENTS.md`）
- ✅ 规范文件使用 `spec.md` 命名
- ✅ 变更提案放在 `changes/<change-id>/` 目录
- ✅ 变更 ID 使用 kebab-case，动词开头（如 `add-user-auth`）

**OpenSpec 工作流**:
1. **创建变更**：创建 `changes/<change-id>/` 目录，包含 `proposal.md`、`tasks.md` 和规范变更
2. **实施变更**：按 `tasks.md` 逐步实施，完成后标记所有任务
3. **归档变更**：部署后移动到 `archive/` 目录

**参考文档**:
- `openspec/AGENTS.md` - AI 助手使用指南
- `openspec/project.md` - 项目规范说明

---

### 4. .promptx/ - PromptX 角色和记忆系统

**路径**: `.promptx/`  
**职责**: PromptX AI 角色配置和记忆存储

**目录结构**:
```
.promptx/
├── resource/            # 项目级角色和工具资源
│   └── role/            # 角色定义
│       └── frontend-senior-developer/  # 前端高级开发角色
├── pouch.json           # PromptX 配置
└── ...                  # 其他 PromptX 文件
```

**主要功能**:
- AI 角色定义和管理
- 记忆网络存储
- 项目级资源管理

**开发规则**:
- ✅ 使用 PromptX 角色系统进行任务协作
- ✅ 重要决策和知识使用 `remember` 保存
- ✅ 开始任务前使用 `recall` 查看相关记忆

---

### 5. docs/ - 项目文档目录（可选）

**路径**: `docs/`  
**职责**: 存放项目相关文档（如需要）

**目录结构**:
```
docs/
├── api/              # API 文档
│   └── api.md        # API 接口文档
├── design/            # 设计文档
│   └── ui-design.md  # UI 设计文档
└── ...                # 其他文档
```

**开发规则**:
- ✅ 项目文档可以放在 `docs/` 目录（可选）
- ✅ 系统规范必须放在 `openspec/specs/` 目录
- ✅ 变更提案必须放在 `openspec/changes/` 目录
- ✅ 项目说明文档放在根目录 `README.md`

**注意**：
- `docs/` 目录是可选的，主要用于非规范类的项目文档
- 所有系统规范和变更提案必须使用 OpenSpec 目录结构

---

### 6. 配置文件根目录

**路径**: 项目根目录  
**职责**: 项目配置文件

**主要文件**:
- `package.json` - npm 项目配置和依赖（JSON 格式）
- `vite.config.ts` - Vite 构建配置（TypeScript 格式）
- `tsconfig.json` - TypeScript 编译配置（JSON 格式）
- `tsconfig.node.json` - Node.js 环境 TypeScript 配置（JSON 格式）
- `index.html` - HTML 入口模板
- `vercel.json` - Vercel 部署配置（JSON 格式）
- `netlify.toml` - Netlify 部署配置（TOML 格式）
- `.gitignore` - Git 忽略文件
- `README.md` - 项目说明文档

**开发规则**:
- ✅ 修改构建配置 → 编辑 `vite.config.ts`（TypeScript）
- ✅ 修改 TypeScript 配置 → 编辑 `tsconfig.json`（JSON）
- ✅ 添加依赖 → 编辑 `package.json`（JSON）后运行 `npm install`
- ✅ 修改部署配置 → 编辑 `vercel.json`（JSON）或 `netlify.toml`（TOML）
- ✅ 配置文件优先使用 JSON/TypeScript 格式，便于版本控制和编辑

---

## 🎯 开发场景快速索引

| 开发任务 | 目标目录 | 优先级 |
|----------|----------|--------|
| 新增页面 | `src/views/新页面名.vue` | 高 |
| 新增可复用组件 | `src/components/类型/组件名.vue` | 高 |
| 新增业务逻辑 | `src/composables/功能名.ts` | 高 |
| 新增工具函数 | `src/utils/工具名.ts` | 中 |
| 新增类型定义 | `src/types/类型名.ts` | 中 |
| 修改路由配置 | `src/router/index.ts` | 高 |
| 修改状态管理 | `src/stores/模块名.ts` | 高 |
| 创建变更提案 | `openspec/changes/<change-id>/` | 中 |
| 编写系统规范 | `openspec/specs/系统名/spec.md` | 中 |
| 编写技术设计 | `openspec/changes/<change-id>/design.md` | 中 |
| 创建项目文档 | `docs/` 或根目录 `README.md` | 低 |
| 修改构建配置 | `vite.config.ts` | 低 |
| 修改 TypeScript 配置 | `tsconfig.json` | 低 |
| 查看设计文档 | `openspec/specs/` 或 `openspec/changes/` | 低 |

---

## 📚 技术栈与工具

### 核心技术

- **Vue 3** (^3.4.21) - 渐进式 JavaScript 框架
- **Vite** (^5.2.0) - 下一代前端构建工具
- **TypeScript** (^5.4.5) - 类型安全的 JavaScript 超集

### 计划集成

- **Vue Router** - 路由管理（待添加）
- **Pinia** - 状态管理（待添加）
- **Element Plus** - UI 组件库（如需要）

### 开发工具

- **ESLint** - 代码检查（待配置）
- **Prettier** - 代码格式化（待配置）
- **OpenSpec** - 规范驱动开发
- **PromptX** - AI 角色和记忆系统

---

## 📝 文档编写规范

### OpenSpec 规范文档

当需要编写系统规范时：

1. **定位规范路径**：在 `openspec/specs/` 下创建对应系统目录
2. **命名规范**：
   - 系统规范：`spec.md`
   - 技术设计：`design.md`（放在变更提案中）
3. **文档结构**：
   ```markdown
   ## ADDED Requirements
   ### Requirement: 功能名称
   系统 SHALL 提供...

   #### Scenario: 成功场景
   - **WHEN** 用户执行操作
   - **THEN** 预期结果
   ```

### 项目文档

- `README.md` - 项目说明、快速开始、部署指南
- `openspec/project.md` - 项目规范、技术栈、开发约定

---

## ⚠️ 重要约定（必须遵守）

### 🔴 禁止事项（绝对禁止）

1. ❌ **禁止手动修改自动生成的代码**
   - `src/vite-env.d.ts` - Vite 自动生成
   - 标记为 `// Auto-generated` 的代码块
   - 编译产物（`dist/` 目录）

2. ❌ **禁止越界开发**
   - 不要在不该修改的目录下创建文件
   - 严格按照目录职责划分进行开发

3. ❌ **禁止跳过 OpenSpec 流程**
   - 重大变更必须创建变更提案
   - 必须等待提案批准后再实施

### ✅ 强制规则（必须执行）

1. ✅ **所有设计文档和规范文档统一放在指定目录**
   - **系统规范**：统一放在 `openspec/specs/` 目录
     - 不允许在其他位置创建规范文档
     - 规范文件使用 `spec.md` 命名
   - **变更提案**：统一放在 `openspec/changes/<change-id>/` 目录
     - 包含 `proposal.md`、`tasks.md` 和规范变更
     - 技术设计文档使用 `design.md` 命名
   - **项目文档**：统一放在项目根目录或 `docs/` 目录（如需要）
     - `README.md` - 项目说明文档（根目录）
     - `docs/` - 其他项目文档（如 API 文档、设计文档等，可选）
   - **禁止在其他位置创建文档**：不允许在 `src/`、`public/` 等代码目录下创建文档文件

2. ✅ **重大变更前先创建变更提案**
   - 在 `openspec/changes/<change-id>/` 创建提案
   - 包含 `proposal.md`、`tasks.md` 和规范变更
   - 变更 ID 使用 kebab-case，动词开头（如 `add-user-auth`）

3. ✅ **新模块开发需同步创建设计文档**
   - 重大功能模块开发前，在 `openspec/changes/<change-id>/design.md` 创建技术设计文档
   - 或在 `openspec/specs/` 下创建对应的系统规范文档
   - 设计文档应包含：架构设计、技术选型、接口设计、数据结构等

4. ✅ **配置文件优先使用 JSON/TypeScript 格式**
   - 构建配置：优先编辑 `vite.config.ts`（TypeScript）
   - 项目配置：优先编辑 `package.json`（JSON）
   - TypeScript 配置：编辑 `tsconfig.json`（JSON）
   - 部署配置：编辑 `vercel.json` 或 `netlify.toml`
   - 避免手动修改自动生成的配置文件

5. ✅ **使用 Vue 3 Composition API**
   - 优先使用 `<script setup>` 语法
   - 使用组合式函数（Composables）组织逻辑
   - 遵循 Vue 3 最佳实践

6. ✅ **TypeScript 严格模式**
   - 启用严格类型检查
   - 避免使用 `any` 类型
   - 所有新增代码必须包含类型定义

7. ✅ **每次任务完成后必须发送完成通知**（见下方详细规则）

---

## 🚨 完成通知（强制规则）

> ⚠️ **这是强制规则，每次任务完成后必须执行**

### 规则要求

1. **TODO 列表最后一项必须是"发送完成通知"**
2. **任务结束前必须检查是否已发送**
3. **即使小改动也要发送**

### 通知命令模板

```bash
cmd /c python -c "import requests; title = r'Cursor\u4efb\u52a1\u5b8c\u6210'.encode().decode('unicode_escape'); msg = r'<完成说明>'.encode().decode('unicode_escape'); payload={'receiver':'gz0149','title': title, 'msg': msg}; r=requests.post('https://newsfeed.4399om.com/api/messages/send.json', json=payload); print('status', r.status_code); print(r.text)"
```

**使用说明**：
- 将 `<完成说明>` 替换为实际的中文说明（使用 `\uXXXX` Unicode 转义格式）
- `status 200` 且 `ret:0` 为成功
- 示例：`\u4f18\u5316\u4e86\u804a\u5929\u6a21\u5757\u6027\u80fd`（优化了聊天模块性能）

### AI 助手执行要求

- 在每次代码修改、文件创建、任务完成后，**自动执行通知命令**
- 不要等待用户提醒，主动发送
- 如果命令执行失败，需要告知用户

---

## 🔗 OpenSpec + PromptX 协作流程

### 协作原则

**核心原则**：OpenSpec 提供规范驱动，PromptX 提供角色协作和记忆积累，两者必须协同工作。

### 阶段 1：OpenSpec 提案创建（提案阶段）

**工作流程**：
```
1. 识别任务类型 → 检测到 proposal/change/spec/plan 等关键词
2. 激活 PromptX 角色 → frontend-tech-lead 或 writer
3. DMN 记忆扫描 → recall(role, null) 查看相关经验
4. 检查现有规范 → openspec list --specs
5. 检查冲突变更 → openspec list
6. 创建提案结构 → proposal.md、tasks.md、design.md（如需要）、spec deltas
7. 验证提案 → openspec validate <change-id> --strict
8. 保存记忆 → remember 记录提案决策
9. 等待批准 → 不开始实施
```

**PromptX 集成点**：
- **角色选择**：架构决策 → `frontend-tech-lead`，文档编写 → `writer`
- **记忆使用**：提案前 recall 查看类似提案经验，提案后 remember 记录决策
- **记忆模板**：见下方"OpenSpec 记忆模板"章节

### 阶段 2：OpenSpec 提案实施（实施阶段）

**工作流程**：
```
1. 识别实施任务 → 检测到 implement/apply/执行/实施 等关键词
2. 激活 PromptX 角色 → frontend-senior-developer 或对应角色
3. DMN 记忆扫描 → recall(role, "<change-id> 实施") 查看相关经验
4. 读取提案文档 → proposal.md、design.md（如存在）、tasks.md
5. 按任务清单执行 → 按 tasks.md 顺序逐步实施
6. 更新任务状态 → 完成后标记 tasks.md 中的任务
7. 保存记忆 → remember 记录实施经验和问题
8. 发送通知 → 实施完成后发送通知
```

**PromptX 集成点**：
- **角色选择**：Vue 组件开发 → `frontend-senior-developer`，架构重构 → `frontend-tech-lead`
- **记忆使用**：实施前 recall 查看类似实施经验，实施后 remember 记录问题和解决方案
- **记忆模板**：见下方"OpenSpec 记忆模板"章节

### 阶段 3：OpenSpec 变更归档（归档阶段）

**工作流程**：
```
1. 识别归档任务 → 部署后需要归档
2. 激活 PromptX 角色 → frontend-tech-lead
3. 归档变更 → openspec archive <change-id> --yes
4. 验证归档 → openspec validate --strict
5. 保存记忆 → remember 记录归档信息
```

### OpenSpec 记忆模板

**提案创建记忆**：
```javascript
mcp_promptx_remember({
  role: "frontend-tech-lead",  // 或 writer
  engrams: [{
    content: "创建了 OpenSpec 提案 <change-id>，包含能力：<能力列表>，技术决策：<决策>，影响范围：<范围>",
    schema: "OpenSpec 提案 <change-id> <能力> 技术决策 影响",
    strength: 0.8,
    type: "PATTERN"
  }]
})
```

**实施经验记忆**：
```javascript
mcp_promptx_remember({
  role: "frontend-senior-developer",
  engrams: [{
    content: "实施 <change-id> 时，关键实现：<实现要点>，遇到的问题：<问题>，解决方案：<方案>",
    schema: "OpenSpec 实施 <change-id> 实现 问题 解决方案",
    strength: 0.7,
    type: "PATTERN"
  }]
})
```

**架构决策记忆**：
```javascript
mcp_promptx_remember({
  role: "frontend-tech-lead",
  engrams: [{
    content: "在 <change-id> 中选择了 <技术方案>，原因：<原因>，替代方案：<替代方案>，权衡：<权衡>",
    schema: "架构决策 <change-id> <技术方案> 原因 权衡",
    strength: 0.9,
    type: "ATOMIC"
  }]
})
```

### 触发条件检查清单

**必须创建 OpenSpec 提案**（满足任一条件）：
- [ ] 包含关键词：`proposal`、`change`、`spec`、`plan`、`提案`、`变更`、`规范`
- [ ] 且包含动作词：`create`、`plan`、`make`、`start`、`help`、`创建`、`规划`、`制定`
- [ ] 或明确提到：`新增功能`、`架构变更`、`重大修改`、`性能优化`、`安全更新`

**跳过提案直接执行**（满足任一条件）：
- [ ] Bug 修复（恢复预期行为）
- [ ] 拼写错误、格式调整、注释修改
- [ ] 非破坏性依赖更新
- [ ] 配置文件修改
- [ ] 现有行为的测试

---

## 🎭 开发团队角色系统（PromptX Role System）

本项目配置了完整的开发团队角色，根据任务类型**自动选择最合适的角色执行**。

### 👥 团队角色清单

| 角色 ID | 名称 | 职责领域 | 激活命令 |
|---------|------|----------|----------|
| `frontend-senior-developer` | 前端高级开发 | Vue 3、组件开发、业务实现 | `mcp_promptx_action({role: "frontend-senior-developer"})` |
| `frontend-tech-lead` | 前端技术负责人 | 前端架构设计、技术决策、团队协调 | `mcp_promptx_action({role: "frontend-tech-lead"})` |
| `writer` | 技术文档 | 设计文档、规范编写 | `mcp_promptx_action({role: "writer"})` |
| `frontend-qa-engineer` | 前端 QA 工程师 | 前端测试、Bug 修复、质量保证 | `mcp_promptx_action({role: "frontend-qa-engineer"})` |

### 🤖 自动角色匹配规则

当收到任务时，根据关键词**自动识别并激活最合适的角色**：

| 关键词 | 匹配角色 | 示例任务 | 优先级 |
|--------|----------|----------|--------|
| **OpenSpec 提案相关**：proposal、change、spec、plan、提案、变更、规范 | `frontend-tech-lead` 或 `writer` | "创建用户认证变更提案" | 最高 |
| **OpenSpec 实施相关**：implement、apply、执行、实施 | `frontend-senior-developer` | "实施用户认证变更" | 高 |
| Vue、组件、页面、路由、状态管理、业务功能 | `frontend-senior-developer` | "新建用户登录页面" | 高 |
| 架构、设计决策、技术方案、协调、前端架构 | `frontend-tech-lead` | "重构状态管理架构" | 高 |
| 文档、规范、OpenSpec、README | `writer` | "编写组件库规范" | 中 |
| 测试、Bug、QA、验证、前端测试 | `frontend-qa-engineer` | "修复路由跳转 Bug" | 中 |

**OpenSpec 角色选择逻辑**：
1. **提案阶段**：
   - 如果涉及架构决策、技术方案 → `frontend-tech-lead`
   - 如果主要是文档编写 → `writer`
   - 如果不确定 → 先激活 `frontend-tech-lead` 分析
2. **实施阶段**：
   - 如果涉及 Vue 组件、业务功能 → `frontend-senior-developer`
   - 如果涉及架构重构 → `frontend-tech-lead`
   - 如果涉及测试、Bug 修复 → `frontend-qa-engineer`

### 🔄 角色协作流程

**单一任务**：
1. 识别关键词 → 自动激活对应角色
2. 角色执行任务
3. 完成后发送通知

**复杂任务**（涉及多领域）：
1. 先激活 `frontend-tech-lead` 分析任务
2. frontend-tech-lead 制定协作计划
3. 按计划逐一调度专业角色
4. frontend-tech-lead 整合结果
5. 完成后发送通知

### 📋 角色使用示例

```
用户: "帮我在 views 下新建一个用户中心页面"
AI: 
  1. 识别关键词 "views"、"页面"
  2. 激活 frontend-senior-developer
  3. 创建页面组件
  4. 发送完成通知

用户: "重构整个状态管理架构"
AI:
  1. 识别为复杂任务
  2. 激活 frontend-tech-lead 先分析
  3. frontend-tech-lead 分配任务给 frontend-senior-developer
  4. 整合结果
  5. 发送完成通知
```

---

## 🧠 记忆系统使用指南（PromptX Memory System）

本项目集成了 PromptX 记忆系统，**请在以下场景中主动使用记忆功能**。

### 📥 何时使用 recall（回忆）

**触发时机**（形成条件反射）：
- ✅ 收到新任务时 → 先用 `recall` 查看相关记忆
- ✅ 遇到不熟悉的模块时 → `recall` 该模块的历史经验
- ✅ 调试问题时 → `recall` 是否有类似问题的解决方案
- ✅ 不确定架构决策时 → `recall` 之前的设计决策

**推荐工作流**：
1. **DMN 全景扫描**：`mcp_promptx_recall({role: "frontend-senior-developer", query: null})` → 看到角色的所有记忆域
2. **多轮深入挖掘**：从返回的网络图中选词 → 继续 `recall` 深入
3. **直到信息充足**：不要一次就停止，持续挖掘相关记忆

**示例场景**：
```
用户请求: "帮我优化组件渲染性能"
AI 行为: 
  1. mcp_promptx_recall({role: "frontend-senior-developer", query: null}) → 看全景
  2. mcp_promptx_recall({role: "frontend-senior-developer", query: "性能 优化 组件"}) → 深入相关领域
  3. 结合记忆 + 代码分析给出方案
  4. mcp_promptx_remember(...) → 保存新方案
```

### 📤 何时使用 remember（记忆）

**触发时机**（形成条件反射）：
- ✅ 回答完用户问题后 → 立即 `remember` 关键点
- ✅ 解决了一个 bug → `remember` 问题原因和解决方案
- ✅ 发现了新知识/技巧 → `remember` 保存
- ✅ recall 返回空白领域 → 必须 `remember` 填补
- ✅ 做了架构决策 → `remember` 决策理由

**记忆模板**（快速完成）：
```javascript
mcp_promptx_remember({
  role: "frontend-senior-developer",  // 使用的角色
  engrams: [{
    content: "刚刚讨论解决的核心内容",
    schema: "关键词1 关键词2 关键词3",  // 空格分隔
    strength: 0.7,  // 默认 0.7 即可
    type: "ATOMIC"  // ATOMIC(具体信息) | LINK(关系) | PATTERN(模式/流程)
  }]
})
```

### 🔄 认知循环（每次任务都应遵循）

```
┌─────────────┐
│ 1.看到任务   │
└──────┬──────┘
       ↓
┌─────────────────────┐
│ 2.DMN扫描网络全景    │ → recall(role, null) 看到所有记忆域
└──────┬──────────────┘
       ↓
┌─────────────────────┐
│ 3.多轮recall深挖     │ → 从网络图选词，逐层深入探索
└──────┬──────────────┘
       ↓
┌─────────────────────┐
│ 4.组织回答           │ → 结合记忆+预训练知识
└──────┬──────────────┘
       ↓
┌─────────────────────┐
│ 5.remember          │ → 保存新知，扩充网络
└─────────────────────┘
```

### 📝 项目相关记忆建议

针对本项目，建议记忆以下类型的信息：

| 记忆类型 | 示例 | type | 适用场景 |
|---------|------|------|----------|
| **OpenSpec 提案经验** | "用户认证提案使用 JWT + Refresh Token 方案" | PATTERN | 创建类似提案时 |
| **OpenSpec 实施经验** | "实施用户认证时遇到路由守卫问题，解决方案：..." | PATTERN | 实施类似变更时 |
| **架构决策记录** | "选择 Pinia 而非 Vuex 的原因：更好的 TypeScript 支持" | ATOMIC | 类似技术选型时 |
| 组件设计模式 | "用户中心页面使用组合式函数管理状态" | PATTERN | 开发新页面时 |
| Bug 修复经验 | "路由跳转失败通常是路径配置问题" | ATOMIC | 调试问题时 |
| 性能优化技巧 | "大列表使用虚拟滚动提升性能" | LINK | 性能优化时 |
| API 使用要点 | "Vue 3 组合式函数需要正确使用响应式 API" | ATOMIC | 开发新功能时 |
| 开发规范 | "新组件必须在 components/ 下按类型分类" | PATTERN | 创建新组件时 |

**OpenSpec 相关记忆模板**：

```javascript
// 提案创建记忆
mcp_promptx_remember({
  role: "frontend-tech-lead",
  engrams: [{
    content: "创建了 OpenSpec 提案 <change-id>，包含能力：<能力列表>，技术决策：<决策>，影响范围：<范围>",
    schema: "OpenSpec 提案 <change-id> <能力> 技术决策 影响",
    strength: 0.8,
    type: "PATTERN"
  }]
})

// 实施经验记忆
mcp_promptx_remember({
  role: "frontend-senior-developer",
  engrams: [{
    content: "实施 <change-id> 时，关键实现：<实现要点>，遇到的问题：<问题>，解决方案：<方案>",
    schema: "OpenSpec 实施 <change-id> 实现 问题 解决方案",
    strength: 0.7,
    type: "PATTERN"
  }]
})

// 架构决策记忆
mcp_promptx_remember({
  role: "frontend-tech-lead",
  engrams: [{
    content: "在 <change-id> 中选择了 <技术方案>，原因：<原因>，替代方案：<替代方案>，权衡：<权衡>",
    schema: "架构决策 <change-id> <技术方案> 原因 权衡",
    strength: 0.9,
    type: "ATOMIC"
  }]
})
```

### ⚠️ 重要提醒

1. **每次对话至少 1 条 remember** - 这是积累知识财富的习惯
2. **recall 空白领域必须 remember 填补** - 让记忆网络越来越丰富
3. **今天的 remember = 明天的快速答案** - 避免重复研究同样问题
4. **不 remember = 永远从零开始** - 浪费时间和精力

---

## 📋 AI 助手行为规范

### 🎯 核心工作流程（必须遵循）

**标准任务流程**：
```
1. 接收任务 → 识别任务类型和关键词
2. 激活 PromptX 角色 → 根据任务类型选择合适角色
3. DMN 记忆扫描 → recall(role, null) 查看相关记忆域
4. 检查 OpenSpec → 查看相关规范和变更提案（如需要）
5. 执行任务 → 遵循目录规范和开发规则
6. 保存记忆 → remember 记录关键信息和决策
7. 发送通知 → 任务完成后自动发送完成通知
```

**OpenSpec 提案流程**（当任务包含关键词：`proposal`、`change`、`spec`、`plan`）：
```
1. 识别为 OpenSpec 任务 → 激活 frontend-tech-lead 或 writer 角色
2. DMN 记忆扫描 → recall(role, "OpenSpec 提案 规范") 查看相关经验
3. 检查现有规范 → openspec list --specs 查看现有能力
4. 检查冲突变更 → openspec list 查看进行中的变更
5. 创建提案结构 → proposal.md、tasks.md、design.md（如需要）、spec deltas
6. 验证提案 → openspec validate <change-id> --strict
7. 保存记忆 → remember 记录提案决策和架构选择
8. 等待批准 → 不开始实施，直到提案被批准
```

**OpenSpec 实施流程**（当任务包含关键词：`implement`、`apply`、`执行`、`实施`）：
```
1. 识别为实施任务 → 激活 frontend-senior-developer 或对应角色
2. DMN 记忆扫描 → recall(role, "OpenSpec 实施 <change-id>") 查看相关经验
3. 读取提案文档 → 读取 proposal.md、design.md（如存在）、tasks.md
4. 按任务清单执行 → 按 tasks.md 顺序逐步实施
5. 更新任务状态 → 完成后标记 tasks.md 中的任务为完成
6. 保存记忆 → remember 记录实施经验和遇到的问题
7. 发送通知 → 实施完成后发送通知
```

**OpenSpec 归档流程**（部署后）：
```
1. 识别为归档任务 → 激活 frontend-tech-lead 角色
2. 归档变更 → openspec archive <change-id> --yes
3. 验证归档 → openspec validate --strict
4. 保存记忆 → remember 记录归档信息和经验
```

### 🔄 OpenSpec + PromptX 集成规则

#### 规则 1：角色选择策略

**OpenSpec 提案阶段**：
- **架构决策、技术方案** → 激活 `frontend-tech-lead`
- **规范文档编写** → 激活 `writer`
- **多系统协作** → 先激活 `frontend-tech-lead` 分析，再调度其他角色

**OpenSpec 实施阶段**：
- **Vue 组件开发、业务功能** → 激活 `frontend-senior-developer`
- **架构重构、技术决策** → 激活 `frontend-tech-lead`
- **测试、Bug 修复** → 激活 `frontend-qa-engineer`

#### 规则 2：记忆系统使用时机

**提案阶段记忆**：
```javascript
// 提案创建前
mcp_promptx_recall({role: "frontend-tech-lead", query: null}) // DMN 全景扫描
mcp_promptx_recall({role: "frontend-tech-lead", query: "OpenSpec 提案 <相关领域>"}) // 深入挖掘

// 提案创建后
mcp_promptx_remember({
  role: "frontend-tech-lead",
  engrams: [{
    content: "创建了 OpenSpec 提案 <change-id>，包含 <能力列表>，技术决策：<决策>",
    schema: "OpenSpec 提案 <change-id> <能力> 技术决策",
    strength: 0.8,
    type: "PATTERN"
  }]
})
```

**实施阶段记忆**：
```javascript
// 实施开始前
mcp_promptx_recall({role: "frontend-senior-developer", query: "<change-id> 实施"})
mcp_promptx_recall({role: "frontend-senior-developer", query: "<相关技术栈>"})

// 实施完成后
mcp_promptx_remember({
  role: "frontend-senior-developer",
  engrams: [{
    content: "完成了 <change-id> 实施，关键实现：<实现要点>，遇到的问题：<问题及解决方案>",
    schema: "OpenSpec 实施 <change-id> 实现 问题解决",
    strength: 0.7,
    type: "PATTERN"
  }]
})
```

#### 规则 3：OpenSpec 触发条件（精确匹配）

**必须创建提案的情况**（关键词匹配）：
- 包含以下任一关键词：`proposal`、`change`、`spec`、`plan`、`提案`、`变更`、`规范`
- 且包含以下任一动作词：`create`、`plan`、`make`、`start`、`help`、`创建`、`规划`、`制定`
- 或明确提到：`新增功能`、`架构变更`、`重大修改`、`性能优化`、`安全更新`

**跳过提案的情况**（直接执行）：
- Bug 修复（恢复预期行为）
- 拼写错误、格式调整、注释修改
- 非破坏性依赖更新
- 配置文件修改
- 现有行为的测试

#### 规则 4：OpenSpec 提案检查清单

**创建提案前必须检查**：
- [ ] 运行 `openspec list --specs` 查看现有能力
- [ ] 运行 `openspec list` 查看进行中的变更
- [ ] 读取 `openspec/project.md` 了解项目约定
- [ ] 使用 `recall` 查看相关记忆和经验
- [ ] 检查是否有冲突的变更提案

**提案创建后必须验证**：
- [ ] 运行 `openspec validate <change-id> --strict` 验证提案
- [ ] 确保每个 Requirement 至少有一个 Scenario
- [ ] 确保 spec deltas 格式正确（## ADDED|MODIFIED|REMOVED Requirements）
- [ ] 确保 change-id 唯一且符合命名规范（kebab-case，动词开头）

#### 规则 5：OpenSpec 实施检查清单

**实施开始前必须**：
- [ ] 确认提案已批准（检查 proposal.md 状态）
- [ ] 读取 proposal.md 理解变更内容
- [ ] 读取 design.md（如存在）了解技术决策
- [ ] 读取 tasks.md 获取实施清单
- [ ] 使用 `recall` 查看相关实施经验

**实施过程中必须**：
- [ ] 按 tasks.md 顺序逐步实施
- [ ] 每个任务完成后立即标记为完成
- [ ] 遇到问题及时记录到 remember
- [ ] 保持代码修改最小化，聚焦于变更目标

**实施完成后必须**：
- [ ] 确认所有 tasks.md 中的任务都标记为完成
- [ ] 运行测试验证功能正常
- [ ] 使用 `remember` 记录实施经验和遇到的问题
- [ ] 发送完成通知

### 响应语言

- **始终使用中文**进行沟通和代码注释
- 技术术语保留英文，必要时提供中文解释
- 代码中的注释可以使用中文

### 代码质量要求

- 遵循 Vue 3 Composition API 最佳实践
- 使用 TypeScript 严格模式
- 新功能必须同步创建 OpenSpec 规范（如需要）
- 所有修改必须符合目录职责划分

### 错误处理

- 如果遇到禁止修改的文件，**立即停止**并提示用户使用正确方法
- 如果任务涉及多个角色，先激活 `frontend-tech-lead` 分析
- 如果记忆系统返回空白，完成后必须 `remember` 填补
- 如果任务需要重大变更，必须先创建 OpenSpec 变更提案
- 如果 OpenSpec 验证失败，必须修复所有问题后再继续

---

## 🔧 常用命令

### 项目开发命令

| 命令 | 功能 | 使用场景 |
|------|------|----------|
| `npm run dev` | 启动开发服务器 | 本地开发时 |
| `npm run build` | 构建生产版本 | 部署前 |
| `npm run preview` | 预览构建结果 | 构建后验证 |

### OpenSpec 命令

| 命令 | 功能 | 使用场景 |
|------|------|----------|
| `openspec list` | 查看变更列表 | 查看进行中的变更 |
| `openspec list --specs` | 查看规范列表 | 查看系统规范 |
| `openspec show <change-id>` | 显示变更详情 | 查看变更内容 |
| `openspec show <spec-id> --type spec` | 显示规范详情 | 查看系统规范 |
| `openspec validate <change-id> --strict` | 验证变更提案 | 创建变更后必须执行 |
| `openspec archive <change-id> --yes` | 归档变更 | 部署后归档 |
| `openspec spec list --long` | 列出所有规范（详细） | 探索现有能力 |

### PromptX 命令（MCP 工具）

| 工具函数 | 功能 | 使用场景 |
|---------|------|----------|
| `mcp_promptx_action({role: "角色ID"})` | 激活指定角色 | 开始任务前选择角色 |
| `mcp_promptx_recall({role: "角色ID", query: null})` | DMN 全景扫描 | 查看角色的所有记忆域 |
| `mcp_promptx_recall({role: "角色ID", query: "关键词"})` | 深入挖掘记忆 | 查看特定领域的记忆 |
| `mcp_promptx_remember({role: "角色ID", engrams: [...]})` | 保存记忆 | 任务完成后保存经验 |
| `mcp_promptx_discover({focus: "all"})` | 发现可用角色和工具 | 查看所有可用资源 |
| `mcp_promptx_project({workingDirectory: "路径"})` | 绑定项目目录 | 激活项目级资源 |

### 命令组合使用示例

**OpenSpec 提案创建流程**：
```bash
# 1. 查看现有规范和变更
openspec list --specs
openspec list

# 2. 创建提案（使用 PromptX 角色）
mcp_promptx_action({role: "frontend-tech-lead"})
mcp_promptx_recall({role: "frontend-tech-lead", query: null})

# 3. 创建提案文件后验证
openspec validate <change-id> --strict
```

**OpenSpec 实施流程**：
```bash
# 1. 查看提案详情
openspec show <change-id>

# 2. 激活实施角色
mcp_promptx_action({role: "frontend-senior-developer"})
mcp_promptx_recall({role: "frontend-senior-developer", query: "<change-id> 实施"})

# 3. 实施完成后保存记忆
mcp_promptx_remember({...})
```

### Git Commit 消息规范（重要）

**⚠️ 在 PowerShell 中提交中文 commit 消息时，必须使用文件方式，避免编码问题**：

#### 方法一：使用文件提交（推荐）

```powershell
# 1. 创建 commit 消息文件（UTF-8 编码）
@"
docs: 根据项目规范整理文档目录结构

- 创建 docs/ 目录并按类型分类组织项目文档
- 移动系统规范到 openspec/specs/ 目录
"@ | Out-File -FilePath commit-msg.txt -Encoding UTF8

# 2. 使用文件提交
git commit -F commit-msg.txt

# 3. 删除临时文件
Remove-Item commit-msg.txt
```

#### 方法二：使用 Git 编辑器

```powershell
# 设置 Git 编辑器为支持 UTF-8 的编辑器
git config --global core.editor "code --wait"  # VS Code
# 或
git config --global core.editor "notepad"      # 记事本

# 使用编辑器提交
git commit
```

#### 方法三：单行消息（简单场景）

```powershell
# 对于简单的单行消息，可以直接使用
git commit -m "fix: 修复组件渲染问题"
```

**重要提示**：
- ✅ 使用文件方式提交多行中文消息（推荐）
- ✅ 确保文件使用 UTF-8 编码保存
- ❌ 避免在 PowerShell 中直接使用 `-m` 参数提交多行中文消息
- ❌ 避免在命令行中直接输入中文，可能导致编码问题

---

---

## 📊 规则优化说明

### 本次优化内容

1. **OpenSpec + PromptX 深度集成**：
   - 在 OpenSpec 工作流的每个阶段明确使用 PromptX 角色和记忆系统
   - 添加了详细的协作流程和记忆模板
   - 明确了角色选择策略和触发条件

2. **规则识别精度提升**：
   - 添加了明确的关键词匹配规则
   - 优化了角色自动匹配逻辑
   - 添加了触发条件检查清单

3. **可执行性增强**：
   - 添加了详细的检查清单
   - 提供了具体的命令组合示例
   - 明确了每个阶段的必做事项

4. **记忆系统优化**：
   - 添加了 OpenSpec 相关的记忆建议
   - 提供了标准化的记忆模板
   - 明确了记忆使用的时机和方式

### 规则遵守要点

**AI 助手必须遵守**：
1. ✅ 所有 OpenSpec 任务必须结合 PromptX 角色和记忆系统
2. ✅ 提案阶段必须激活 `frontend-tech-lead` 或 `writer` 角色
3. ✅ 实施阶段必须激活 `frontend-senior-developer` 或对应角色
4. ✅ 每个阶段必须使用 `recall` 查看相关记忆
5. ✅ 每个阶段完成后必须使用 `remember` 保存经验
6. ✅ 必须遵循 OpenSpec 工作流程（见 `openspec/AGENTS.md`）
7. ✅ 必须验证提案（`openspec validate <change-id> --strict`）

**规则识别优先级**：
1. **OpenSpec 任务**（最高优先级）→ 检测到 proposal/change/spec/plan 等关键词
2. **PromptX 角色任务**（高优先级）→ 检测到 Vue/组件/架构/文档/测试等关键词
3. **标准开发任务**（默认）→ 遵循标准工作流程

### 进一步优化建议

1. **规则测试**：
   - 建议在实际任务中测试规则识别和执行的准确性
   - 根据实际使用情况调整关键词匹配规则

2. **记忆积累**：
   - 持续使用 `remember` 积累项目经验
   - 定期使用 `recall` 查看记忆网络，发现知识盲点

3. **规则迭代**：
   - 根据项目发展需要，持续优化规则文件
   - 保持规则文件与实际工作流程同步

4. **文档同步**：
   - 确保 `openspec/AGENTS.md` 与规则文件保持一致
   - 及时更新规则文件中的示例和模板

---

**最后更新**: 2025  
**版本**: 2.0（OpenSpec + PromptX 深度集成优化版）

